#
# This is a Flox environment manifest.
# Visit flox.dev/docs/concepts/manifest/
# or see flox-edit(1), manifest.toml(5) for more information.
#
version = 1

# List packages you wish to install in your environment inside
# the `[install]` section.
[install]
coreutils.pkg-path = "coreutils"
findutils.pkg-path = "findutils"
gnutar.pkg-path = "gnutar"
lychee.pkg-path = "lychee"
pandoc.pkg-path = "pandoc"
poetry.pkg-path = "poetry"
python.pkg-path = "python3"
python.version = "3.11.*"
pngquant.pkg-path = "pngquant"
gnused.pkg-path = "gnused"

# Set environment variables in the `[vars]` section. These variables may not
# reference one another, and are added to the environment without first
# expanding them. They are available for use in the `[profile]` and `[hook]`
# scripts.
[vars]
# message = "Howdy"

# The `hook.on-activate` script is run by the *bash* shell immediately upon
# activating an environment, and will not be invoked if Flox detects that the
# environment has previously been activated. Variables set by the script will
# be inherited by `[profile]` scripts defined below. Note that any stdout
# generated by the script will be redirected to stderr.
[hook]
on-activate = '''

#
# Python environment activation and installation
#
export POETRY_VIRTUALENVS_PATH="$FLOX_ENV_CACHE/poetry/virtualenvs"
if [ -z "$(poetry env info --path)" ]; then
  poetry env use python &> /dev/null
fi
source "$(poetry env info --path)/bin/activate" &> /dev/null
poetry install --quiet &> /dev/null
echo "1. ğŸ‘‰ Python environment activated"


# 
# Set the version of Flox to the latest stable version
#
export FLOX_VERSION=$(curl -s https://downloads.flox.dev/by-env/stable/LATEST_VERSION | xargs)
echo "2. ğŸ‘‰ FLOX_VERSION set to $FLOX_VERSION"


# 
# Copy and process Flox man pages
# 
export FLOX_SRC_ARCHIVE="$FLOX_ENV_CACHE/flox-v$FLOX_VERSION.tar.gz"
if [ ! -e "$FLOX_SRC_ARCHIVE" ]; then
  curl -sL "https://github.com/flox/flox/archive/refs/tags/v$FLOX_VERSION.tar.gz" -o $FLOX_SRC_ARCHIVE
fi
echo "3. ğŸ‘‰ Downloaded Flox source archive"

export FLOX_SRC_DIR="$FLOX_ENV_CACHE/flox-src-$FLOX_VERSION"
if [ ! -d "$FLOX_SRC_DIR" ]; then
  mkdir -p $FLOX_SRC_DIR
  tar -zx --strip-components=1 --file=$FLOX_SRC_ARCHIVE --directory=$FLOX_SRC_DIR;
fi
echo "4. ğŸ‘‰ Extracted Flox source archive"

export FLOX_MAN_PAGES_DIR="$PWD/docs/reference/command-reference"
if [ -d "$FLOX_MAN_PAGES_DIR" ]; then
  rm -rf "$FLOX_MAN_PAGES_DIR/*"
fi
mkdir -p $FLOX_MAN_PAGES_DIR
pushd "$FLOX_SRC_DIR/cli/flox/doc" > /dev/null
  find . -maxdepth 1 -iname "*.md" -exec \
    sh -c "
      pandoc -t gfm \
        -L $FLOX_SRC_DIR/pkgs/flox-manpages/pandoc-filters/include-files.lua \
        --standalone \
        {} |
        # remove current title
        tail -n +6 |
        # indent all markdown levels by one, e.g. "#" -> "##"
        sed -e 's/^#/##/' > \"$FLOX_MAN_PAGES_DIR/{}\"
    " \;
popd > /dev/null
pushd $FLOX_MAN_PAGES_DIR > /dev/null
  for commandPage in ./*.md; do
    # All other man page files have names of the form
    # 'flox*.md'
    if [ "$commandPage" = "./manifest.toml.md" ]; then
      continue
    fi
    command=$(basename $commandPage .md | sed -e "s|-| |g")
    echo -e "\n# \`$command\` command\n$(cat $commandPage)" > $commandPage
    echo -e "---\n$(cat $commandPage)" > $commandPage
    echo -e "description: Command reference for the \`$command\` command.\n$(cat $commandPage)" > $commandPage
    echo -e "title: $command\n$(cat $commandPage)" > $commandPage
    echo -e "---\n$(cat $commandPage)" > $commandPage
  done

  manifestPage="manifest.toml.md"
  echo -e "\n# \`manifest.toml\`\n$(cat $manifestPage)" > $manifestPage
  echo -e "---\n$(cat $manifestPage)" > $manifestPage
  echo -e "description: Reference for the manifest.toml format.\n$(cat $manifestPage)" > $manifestPage
  echo -e "title: manifest.toml\n$(cat $manifestPage)" > $manifestPage
  echo -e "---\n$(cat $manifestPage)" > $manifestPage
popd > /dev/null
echo "5. ğŸ‘‰ Copy man pages from Flox source archive"

echo ""
echo "     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "     â•‘                                   â•‘"
echo "     â•‘  To build a production docs run:  â•‘"
echo "     â•‘  > mkdocs build --strict          â•‘"
echo "     â•‘                                   â•‘"
echo "     â•‘  To write docs locally run:       â•‘"
echo "     â•‘  > mkdocs serve                   â•‘"
echo "     â•‘                                   â•‘"
echo "     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

'''

# Scripts defined in the `[profile]` section are *sourced* by *your shell* and
# inherit environment variables set in the `[vars]` section and by `[hook]` scripts.
# The `profile.common` script is sourced by all shells and special care should be
# taken to ensure compatibility with all shells, after which exactly one of
# `profile.{bash,fish,tcsh,zsh}` is sourced by the corresponding shell.
[profile]
bash = '''
  source "$(poetry env info --path)/bin/activate"
'''
fish = '''
  source "$(poetry env info --path)/bin/activate.fish"
'''
tcsh = '''
  source "$(poetry env info --path)/bin/activate.csh"
'''
zsh = '''
  source "$(poetry env info --path)/bin/activate"
'''

# The `[services]` section of the manifest allows you to define services.
# Services defined here use the packages provided by the `[install]` section
# and any variables you've defined in the `[vars]` section or `hook.on-activate` script.
[services]
mkdocs.command = "mkdocs serve"
mkdocs.is-daemon = false

# Additional options can be set in the `[options]` section. Refer to
# manifest.toml(5) for a list of available options.
[options]
systems = ["aarch64-darwin", "aarch64-linux", "x86_64-darwin", "x86_64-linux"]
# Uncomment to disable CUDA detection.
cuda-detection = false
